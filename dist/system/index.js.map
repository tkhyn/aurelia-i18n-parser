{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"/source/","sourcesContent":["import through from 'through2';\r\nimport gutil from \"gulp-util\";\r\nimport _ from \"lodash\";\r\nimport fs from \"graceful-fs\";\r\nimport jsdom from \"jsdom\";\r\nimport $ from \"jquery\";\r\n\r\nimport {hashFromString,mergeHash,replaceEmpty,transformText} from \"./helpers\";\r\nimport path from \"path\";\r\nimport File from \"vinyl\";\r\nimport {AppExtractor} from \"./app-extractor\";\r\n\r\nimport corejs from \"core-js\";\r\nvar Promise = corejs.Promise;\r\n\r\nvar PluginError = gutil.PluginError;\r\n\r\nconst PLUGIN_NAME = \"aurelia-i18n-parser\";\r\n\r\nconst OBJ_REGEXP = new RegExp(/^\\s*\\{\\s*([\\s\\S]*)\\s*\\}\\s*$/);\r\nconst KEY_VALUE_REGEXP = new RegExp(/\\s*['\"]?([\\w]*)['\"]?\\s*:\\s*(\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]|[^,]*)\\s*,?\\s*(?=$|[\"'\\w]+)/g);\r\nconst KEY_VALUE_REGEXP_T = new RegExp(/('.*'|\".*\")\\s*\\|\\s*t\\s*:?\\s*(.*?)\\s*(?:\\||$)/)\r\n\r\n\r\nexport class Parser{\r\n\r\n    verbose = false;\r\n    defaultNamespace ='translation';\r\n    functions = ['t'];\r\n    namespaceSeparator = \":\";\r\n    translationAttribute = \"data-i18n\";\r\n    imageAttribute = \"data-src\";\r\n    keySeparator = \".\";\r\n    functionsParamsExclude = ['key: string, options: any'];\r\n    appPath = null;\r\n    localesPath = \"src/locales\";\r\n    routesModuleId = \"routes\";\r\n    locales = ['en-US'];\r\n    defaultLocale = \"en\";\r\n    shortcutFunction = 'sprintf';\r\n    bindAttrs = ['bind', 'one-way', 'two-way', 'one-time'];\r\n\r\n    registry = [];\r\n    values = {};\r\n    nodes = {};\r\n\r\n    constructor(opts){\r\n        if(opts) Object.assign(this,opts);\r\n\r\n        if(this.appPath) this.extractor = new AppExtractor(this.appPath);\r\n    }\r\n\r\n    parse(){\r\n        return this.stream = through.obj(this.transformFile.bind(this), this.flush.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Figures out how to parse the data based on file extension.\r\n     *\r\n     * @param path          path to the file\r\n     * @param data          data of the file\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseTranslations(path,data){\r\n        var ext = this.getExtension(path);\r\n        switch(ext){\r\n            case 'html':\r\n                if(this.verbose) gutil.log(\"parse HTML:\",path);\r\n                return this.parseHTML(data, path);\r\n            default:\r\n                if(this.verbose) gutil.log(\"parse JS:\",path);\r\n                return this.parseJavaScript(data, path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from an array of (key, options) strings\r\n     * @returns {Array}     the extracted translation keys\r\n     */\r\n\r\n    parseKeyOptions(keyOptions, path) {\r\n        var keys = [],\r\n            _this2 = this,\r\n            key, options;\r\n\r\n        keyOptions.forEach(function(keyOption) {\r\n\r\n            [key, options] = keyOption;\r\n\r\n            try {\r\n                key = eval(key.replace(/this./g, ''));\r\n\r\n                keys.push(key);\r\n\r\n                // try and extract default value from options\r\n                if (!options) {\r\n                    return;\r\n                }\r\n\r\n                var defaultValue = undefined;\r\n                try {\r\n                    options = OBJ_REGEXP.exec(options);\r\n\r\n                    if (options === null) {\r\n                        // we have a single value, possibly because\r\n                        // i18next is used with shortcutFunction: 'defaultValue'\r\n                        // and 'options' is a string that should be evaluated\r\n                        if (this.shortcutFunction == 'defaultValue') {\r\n                            defaultValue = options;\r\n                            defaultValue = eval('(' + defaultValue + ')');\r\n                        }\r\n                    } else {\r\n                        // options is an object, parse the keys\r\n                        var kv;\r\n                        while (kv = KEY_VALUE_REGEXP.exec(options[1])) {\r\n                            if (kv[1] == 'defaultValue') {\r\n                                defaultValue = kv[2];\r\n                                defaultValue = eval(`(${defaultValue})`);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (defaultValue) {\r\n                        _this2.values[key] = defaultValue;\r\n                    }\r\n                } catch (e) {\r\n                    console.warn(`Unable to parse default value \"${defaultValue}\" for key \"${key}\" in file ${path}. Error: ${e}`);\r\n                }\r\n            } catch (e) {\r\n                console.warn(`Unable to parse key \"${key}\" in file ${path}. Error: ${e}`);\r\n            }\r\n\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    /**\r\n     * Extract translations from javascript code.\r\n     *\r\n     * @param data          javascript code as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseJavaScript(data, path){\r\n        var fnPattern = '(?:' + this.functions.join('\\\\()|(?:').replace('.', '\\\\.') + '\\\\()';\r\n        var pattern = '[^a-zA-Z0-9_](?:'+ fnPattern +')([^);]*)';\r\n        var functionRegex = new RegExp(pattern, 'g');\r\n\r\n        var matches, keyOption;\r\n        var keyOptions = [];\r\n\r\n        while( matches = functionRegex.exec(data) ){\r\n            // parameters pairs are always in third element of matches array\r\n            if (matches.length > 1) {\r\n                var argsMatch = matches[1]; //replace spaces with empty\r\n                var argsMatchTrim = argsMatch.replace(/ /g, '');\r\n                if (!this.functionsParamsExclude || this.functionsParamsExclude.map(function(item) {return item.replace(/ /g, '');}).indexOf(argsMatchTrim) < 0) {\r\n\r\n                    keyOption = argsMatch.split( /,([\\s\\S]+)/);\r\n\r\n                    if (keyOption && keyOption[0]) {\r\n                        keyOptions.push(keyOption);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.resolve(this.parseKeyOptions(keyOptions, path));\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param data          html markup as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseHTML(data, path){\r\n        return new Promise((resolve, reject) =>{\r\n            jsdom.env({\r\n                html: data,\r\n                done: (errors, window)=>{\r\n                    if(errors){\r\n                        //throw new new PluginError(PLUGIN_NAME, 'Streams are not supported!');\r\n                        gutil.log(errors);\r\n                        reject(errors);\r\n                        return;\r\n                    }\r\n                    resolve(this.parseAureliaBindings(data, path).concat(this.parseDOM(window, $)));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Extract translations from aurelia bindnigs.\r\n    *\r\n    * @param window          a jsdom window\r\n    * @param $               jquery\r\n    * @returns {Array}       extracted keys\r\n    */\r\n    parseAureliaBindings(html, path) {\r\n\r\n        var bindingsPattern = '(?:\\\\.(?:' + this.bindAttrs.join('|') + ')\\\\s*=\\\\s*(?:\"(.*)\"|\\'(.*)\\')|\\\\$\\\\{(.*)\\\\})',\r\n            bindingsRegex = new RegExp(bindingsPattern, 'g'),\r\n            keyOptions = [],\r\n            boundExpr, keyOption;\r\n\r\n        while(boundExpr = bindingsRegex.exec(html)) {\r\n\r\n            keyOption = KEY_VALUE_REGEXP_T.exec(boundExpr[1]);\r\n\r\n            if (keyOption) {\r\n                keyOptions.push(keyOption.slice(1));\r\n            }\r\n\r\n        }\r\n\r\n        return this.parseKeyOptions(keyOptions, path);\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param window          a jsdom window\r\n     * @param $               jquery\r\n     * @returns {Array}       extracted keys\r\n     */\r\n    parseDOM(window,$){\r\n        $ = $(window);\r\n        var keys = [];\r\n        var selector = `[${this.translationAttribute}]`;\r\n        var nodes = $(selector);\r\n\r\n        nodes.each(i=>{\r\n            var node = nodes.eq(i);\r\n            var value,key,m;\r\n\r\n            key = node.attr(this.translationAttribute);\r\n\r\n            var attr = \"text\";\r\n            //set default attribute to src if this is an image node\r\n            if(node[0].nodeName===\"IMG\") attr = \"src\";\r\n\r\n            var re = /\\[([a-z]*)]/g;\r\n            //check if a attribute was specified in the key\r\n            while ((m = re.exec(key)) !== null) {\r\n                if (m.index === re.lastIndex) {\r\n                    re.lastIndex++;\r\n                }\r\n                if(m){\r\n                    key = key.replace(m[0],'');\r\n                    attr = m[1];\r\n                }\r\n            }\r\n\r\n            switch(node[0].nodeName){\r\n                case \"IMG\":\r\n                    value = node.attr(this.imageAttribute);\r\n                    break;\r\n                default:\r\n                    switch(attr){\r\n                        case 'text':\r\n                            value = node.text().trim();\r\n                            break;\r\n                        case 'prepend':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'append':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'html':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        default: //custom attribute\r\n                            value = node.attr(attr);\r\n                            break;\r\n                    }\r\n            }\r\n\r\n            //skip keys with interpolations\r\n            if(key.indexOf(\"${\") > -1){\r\n                return;\r\n            }\r\n\r\n            // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            // remove the optional attribute\r\n            key = key.replace(/\\[[a-z]*]/g, '');\r\n\r\n            if(!key) key = value;\r\n            keys.push(key);\r\n            this.values[key] = value;\r\n            this.nodes[key] = node;\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n    /**\r\n     * Parse and add keys to the registry.\r\n     * @param keys\r\n     */\r\n    addToRegistry(keys){\r\n        for(let key of keys){\r\n        // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            if(key.indexOf(this.namespaceSeparator) === -1){\r\n                key = this.defaultNamespace + this.keySeparator + key;\r\n            }else{\r\n                key = key.replace(this.namespaceSeparator, this.keySeparator);\r\n            }\r\n\r\n            this.registry.push(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate translation files from the current registry entries.\r\n     *\r\n     * @param locale\r\n     */\r\n    generateTranslation(locale){\r\n\r\n        var mergedTranslations, currentTranslations, oldTranslations, key;\r\n\r\n        this.registryHash = {};\r\n\r\n        // turn the array of keys\r\n        // into an associative object\r\n        // ==========================\r\n        for(var i = 0, l = this.registry.length; i < l; i++){\r\n            key = this.registry[i];\r\n            this.registryHash = hashFromString(key, '', this.keySeparator, this.registryHash);\r\n        }\r\n\r\n        for(var namespace in this.registryHash){\r\n            if(!this.registryHash.hasOwnProperty(namespace)) continue;\r\n\r\n            // get previous version of the files\r\n            var namespacePath = namespace + '.json';\r\n            //var namespaceOldPath = namespace + '_old.json';\r\n\r\n            var basePath = this.localesPath+\"/\"+locale+\"/\";\r\n            if(this.verbose) gutil.log('basePath', basePath);\r\n\r\n            if(fs.existsSync(basePath+namespacePath)){\r\n                try{\r\n                    currentTranslations = JSON.parse(fs.readFileSync(basePath+namespacePath));\r\n                }catch(error){\r\n                    this.emit('json_error', error.name, error.message);\r\n                    currentTranslations = {};\r\n                }\r\n            }else{\r\n                currentTranslations = {};\r\n            }\r\n\r\n            //if(fs.existsSync(basePath+namespaceOldPath)){\r\n            //  try{\r\n            //    oldTranslations = JSON.parse(fs.readFileSync(basePath+namespaceOldPath));\r\n            //  }\r\n            //  catch(error){\r\n            //    this.emit('json_error', error.name, error.message);\r\n            //    currentTranslations = {};\r\n            //  }\r\n            //}\r\n            //else{\r\n            //  oldTranslations = {};\r\n            //}\r\n\r\n            oldTranslations = {};\r\n\r\n            // merges existing translations with the new ones\r\n            mergedTranslations = mergeHash(currentTranslations, Object.assign({}, this.registryHash[namespace]));\r\n\r\n            // restore old translations if the key is empty\r\n            mergedTranslations.new = replaceEmpty(oldTranslations, mergedTranslations.new);\r\n\r\n            var transform = null;\r\n            //transform values found in the html to uppercase if this is not the default language\r\n            if(locale !== this.defaultLocale) transform = \"uppercase\";\r\n\r\n            mergedTranslations.new = this.getValuesFromHash(this.valuesHash, mergedTranslations.new,transform,this.nodesHash,this.valuesHash);\r\n\r\n            // merges former old translations with the new ones\r\n            mergedTranslations.old = _.extend(oldTranslations, mergedTranslations.new);\r\n\r\n            // push files back to the stream\r\n            var mergedTranslationsFile = new File({\r\n                path: locale+\"/\"+namespacePath,\r\n                //base: locale,\r\n                contents: new Buffer(JSON.stringify(mergedTranslations.new, null, 2))\r\n            });\r\n            //var mergedOldTranslationsFile = new File({\r\n            //  path: locale+\"/\"+namespaceOldPath,\r\n            //  //base: locale,\r\n            //  contents: new Buffer(JSON.stringify(mergedTranslations.old, null, 2))\r\n            //});\r\n\r\n            /*if(this.verbose){\r\n              gutil.log('writing', locale+\"/\"+namespacePath);\r\n              gutil.log('writing', locale+\"/\"+namespaceOldPath);\r\n            }*/\r\n\r\n            this.stream.push(mergedTranslationsFile);\r\n            //this.stream.push(mergedOldTranslationsFile);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Generate translations for all locales from the registry\r\n     */\r\n    generateAllTranslations(){\r\n        this.updateHashes();\r\n\r\n        if(this.verbose) {\r\n            gutil.log('extracted registry:');\r\n            gutil.log(this.registry);\r\n        }\r\n\r\n        for(var i = 0, l = this.locales.length; i < l; i++){\r\n            this.generateTranslation(this.locales[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from the Aurelia app.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    extractFromApp(){\r\n        return this.extractor.getNavFromRoutes(this.routesModuleId)\r\n         .then(navRoutes=>{\r\n             if(!navRoutes) return null;\r\n\r\n             for(var i = 0, l = navRoutes.length; i < l; i++){\r\n                 var item = navRoutes[i];\r\n                 this.values[item.i18n] = item.title;\r\n                 this.registry.push(this.defaultNamespace + this.keySeparator + item.i18n);\r\n             }\r\n\r\n             if(this.verbose){\r\n                 gutil.log('navRoutes found:');\r\n                 gutil.log(navRoutes)\r\n             }\r\n\r\n             return null;\r\n         });\r\n    }\r\n\r\n    /**\r\n     * Takes a `target` hash and replace its empty\r\n     * values with the `source` hash ones if they exist\r\n     *\r\n     * @param source\r\n     * @param target\r\n     * @param transform\r\n     * @param nodesHash\r\n     * @param valuesHash\r\n     * @returns {*|{}}\r\n     */\r\n    getValuesFromHash(source, target,transform,nodesHash,valuesHash){\r\n        target = target || {};\r\n\r\n        Object.keys(source).forEach((key)=>{\r\n\r\n            var node = null;\r\n            if(nodesHash) node = nodesHash[key];\r\n            var value;\r\n\r\n            if(target[key] !== undefined){\r\n                if(typeof source[key] === 'object'){\r\n                    target[key] = this.getValuesFromHash(source[key], target[key], transform, node,(valuesHash)? valuesHash[key] : valuesHash);\r\n                }else if(target[key] === ''){\r\n                    if(!node) {\r\n                        //try to find in values\r\n                        if(valuesHash)value = valuesHash[key];\r\n                        if(transform === \"uppercase\") value = transformText(value);\r\n                    }else{\r\n                        value = source[key];\r\n                        if(transform === \"uppercase\" && node[0].nodeName !== \"IMG\") value = transformText(value);\r\n                    }\r\n                    target[key] = value;\r\n                }\r\n            }\r\n        });\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Get the file extension from a filepath.\r\n     *\r\n     * @param path        path to analyze\r\n     * @returns {string}  the extracted file extension\r\n     */\r\n    getExtension(path){\r\n        return path.substr(path.lastIndexOf(\".\") + 1);\r\n    }\r\n\r\n    /**\r\n     * Update hashes.\r\n     */\r\n    updateHashes(){\r\n\r\n        this.translationsHash = {};\r\n        this.valuesHash = {};\r\n        this.nodesHash = {};\r\n\r\n        var key;\r\n\r\n        // remove duplicate keys\r\n        this.translations = _.uniq(this.translations).sort();\r\n\r\n        //create hash for values\r\n        for(key in this.values){\r\n            if(!this.values.hasOwnProperty(key)) continue;\r\n            this.valuesHash = hashFromString(key, this.values[key], this.keySeparator, this.valuesHash);\r\n        }\r\n        //create hash for nodes\r\n        for(key in this.nodes){\r\n            if(!this.nodes.hasOwnProperty(key)) continue;\r\n            this.nodesHash = hashFromString(key, this.nodes[key], this.keySeparator, this.nodesHash);\r\n        }\r\n    }\r\n\r\n    //--------- Steam functions\r\n\r\n    transformFile(file, encoding, cb) {\r\n\r\n        var data,path;\r\n\r\n        // we do not handle streams\r\n        if (file.isStream()) {\r\n            this.emit('error', new PluginError(PLUGIN_NAME, 'Streams are not supported!'));\r\n            return cb();\r\n        }\r\n\r\n        //read the file manually if a filepath was passed.\r\n        if(file.isNull()){\r\n            path = file.path;\r\n            if(file.stat.isDirectory()){\r\n                return cb();\r\n            }else if(path && fs.existsSync(path)){\r\n                data = fs.readFileSync(path);\r\n            }else{\r\n                this.emit(\"error\", new PluginError(PLUGIN_NAME, \"File has no content and is not readable\"));\r\n                return cb();\r\n            }\r\n        }\r\n\r\n        if (file.isBuffer()) {\r\n            path = file.path.replace(process.cwd()+\"/\",\"\");\r\n            data = file.contents.toString();\r\n        }\r\n\r\n        //skip if no data was found\r\n        if(!data) return cb();\r\n\r\n        data = this.parseTranslations(path,data).then(keys=>{\r\n            this.addToRegistry(keys);\r\n            // tell the stream engine that we are done with this file\r\n            cb();\r\n        });\r\n\r\n        // make sure the file goes through the next gulp plugin\r\n        //this.push(file);\r\n    }\r\n\r\n    flush(cb){\r\n        //extract values from the aurelia application where possible\r\n        if(this.extractor){\r\n            this.extractFromApp().then(()=>{\r\n                this.generateAllTranslations();\r\n                cb();\r\n            });\r\n        }else{\r\n            this.generateAllTranslations();\r\n            cb();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The main plugin function\r\n *\r\n * @param opts\r\n * @returns {Stream}\r\n */\r\nexport function parse(opts) {\r\n    return new Parser(opts).parse();\r\n}\r\n"]}