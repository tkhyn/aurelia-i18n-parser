{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"/source/","sourcesContent":["import through from 'through2';\r\nimport gutil from \"gulp-util\";\r\nimport _ from \"lodash\";\r\nimport fs from \"graceful-fs\";\r\nimport jsdom from \"jsdom\";\r\nimport $ from \"jquery\";\r\n\r\nimport {hashFromString,mergeHash,replaceEmpty,transformText} from \"./helpers\";\r\nimport path from \"path\";\r\nimport File from \"vinyl\";\r\nimport {AppExtractor} from \"./app-extractor\";\r\n\r\nimport corejs from \"core-js\";\r\nvar Promise = corejs.Promise;\r\n\r\nvar PluginError = gutil.PluginError;\r\n\r\nconst PLUGIN_NAME = \"aurelia-i18n-parser\";\r\n\r\nconst OBJ_REGEXP = new RegExp(/^\\s*\\{\\s*([\\s\\S]*)\\s*\\}\\s*$/);\r\nconst KEY_VALUE_REGEXP = new RegExp(/\\s*['\"]?([\\w]*)['\"]?\\s*:\\s*(\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]|[^,]*)\\s*,?\\s*(?=$|[\"'\\w]+)/g);\r\nconst KEY_VALUE_REGEXP_T = new RegExp(/('.*'|\".*\")\\s*\\|\\s*t\\s*:\\s*(.*?)\\s*(?:\\||$)/)\r\n\r\n\r\nexport class Parser{\r\n\r\n    verbose = false;\r\n    defaultNamespace ='translation';\r\n    functions = ['t'];\r\n    namespaceSeparator = \":\";\r\n    translationAttribute = \"data-i18n\";\r\n    imageAttribute = \"data-src\";\r\n    keySeparator = \".\";\r\n    functionsParamsExclude = ['key: string, options: any'];\r\n    appPath = null;\r\n    localesPath = \"src/locales\";\r\n    routesModuleId = \"routes\";\r\n    locales = ['en-US'];\r\n    defaultLocale = \"en\";\r\n    shortcutFunction = 'sprintf';\r\n    bindAttrs = ['bind', 'one-way', 'two-way', 'one-time'];\r\n\r\n    registry = [];\r\n    values = {};\r\n    nodes = {};\r\n\r\n    constructor(opts){\r\n        if(opts) Object.assign(this,opts);\r\n\r\n        if(this.appPath) this.extractor = new AppExtractor(this.appPath);\r\n    }\r\n\r\n    parse(){\r\n        return this.stream = through.obj(this.transformFile.bind(this), this.flush.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Figures out how to parse the data based on file extension.\r\n     *\r\n     * @param path          path to the file\r\n     * @param data          data of the file\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseTranslations(path,data){\r\n        var ext = this.getExtension(path);\r\n        switch(ext){\r\n            case 'html':\r\n                if(this.verbose) gutil.log(\"parse HTML:\",path);\r\n                return this.parseHTML(data, path);\r\n            default:\r\n                if(this.verbose) gutil.log(\"parse JS:\",path);\r\n                return this.parseJavaScript(data, path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from an array of (key, options) strings\r\n     * @returns {Array}     the extracted translation keys\r\n     */\r\n\r\n    parseKeyOptions(keyOptions, path) {\r\n        var keys = [],\r\n            _this2 = this,\r\n            key, options;\r\n\r\n        keyOptions.forEach(function(keyOption) {\r\n\r\n            [key, options] = keyOption;\r\n\r\n            try {\r\n                key = eval(key.replace(/this./g, ''));\r\n\r\n                keys.push(key);\r\n\r\n                // try and extract default value from options\r\n                if (options === undefined) {\r\n                    return;\r\n                }\r\n\r\n                var defaultValue = undefined;\r\n                try {\r\n                    options = OBJ_REGEXP.exec(options)[1];\r\n\r\n                    if (options === null) {\r\n                        // we have a single value, possibly because\r\n                        // i18next is used with shortcutFunction: 'defaultValue'\r\n                        // and 'options' is a string that should be evaluated\r\n                        if (this.shortcutFunction == 'defaultValue') {\r\n                            defaultValue = options;\r\n                            defaultValue = eval('(' + defaultValue + ')');\r\n                        }\r\n                    } else {\r\n                        // options is an object, parse the keys\r\n                        var kv;\r\n                        while (kv = KEY_VALUE_REGEXP.exec(options)) {\r\n                            if (kv[1] == 'defaultValue') {\r\n                                defaultValue = kv[2];\r\n                                defaultValue = eval(`(${defaultValue})`);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (defaultValue) {\r\n                        _this2.values[key] = defaultValue;\r\n                    }\r\n                } catch (e) {\r\n                    console.warn(`Unable to parse default value \"${defaultValue}\" for key \"${key}\" in file ${path}. Error: ${e}`);\r\n                }\r\n            } catch (e) {\r\n                console.warn(`Unable to parse key \"${key}\" in file ${path}. Error: ${e}`);\r\n            }\r\n\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    /**\r\n     * Extract translations from javascript code.\r\n     *\r\n     * @param data          javascript code as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseJavaScript(data, path){\r\n        var fnPattern = '(?:' + this.functions.join('\\\\()|(?:').replace('.', '\\\\.') + '\\\\()';\r\n        var pattern = '[^a-zA-Z0-9_](?:'+ fnPattern +')([^);]*)';\r\n        var functionRegex = new RegExp(pattern, 'g');\r\n\r\n        var matches, keyOption;\r\n        var keyOptions = [];\r\n\r\n        while( matches = functionRegex.exec(data) ){\r\n            // parameters pairs are always in third element of matches array\r\n            if (matches.length > 1) {\r\n                var argsMatch = matches[1]; //replace spaces with empty\r\n                var argsMatchTrim = argsMatch.replace(/ /g, '');\r\n                if (!this.functionsParamsExclude || this.functionsParamsExclude.map(function(item) {return item.replace(/ /g, '');}).indexOf(argsMatchTrim) < 0) {\r\n\r\n                    keyOption = argsMatch.split( /,([\\s\\S]+)/);\r\n\r\n                    if (keyOption && keyOption[0]) {\r\n                        keyOptions.push(keyOption);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.resolve(this.parseKeyOptions(keyOptions, path));\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param data          html markup as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseHTML(data, path){\r\n        return new Promise((resolve, reject) =>{\r\n            jsdom.env({\r\n                html: data,\r\n                done: (errors, window)=>{\r\n                    if(errors){\r\n                        //throw new new PluginError(PLUGIN_NAME, 'Streams are not supported!');\r\n                        gutil.log(errors);\r\n                        reject(errors);\r\n                        return;\r\n                    }\r\n                    resolve(this.parseAureliaBindings(data, path));\r\n                    resolve(this.parseDOM(window,$));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Extract translations from aurelia bindnigs.\r\n    *\r\n    * @param window          a jsdom window\r\n    * @param $               jquery\r\n    * @returns {Array}       extracted keys\r\n    */\r\n    parseAureliaBindings(html, path) {\r\n\r\n        var bindingsPattern = '(?:\\\\.(?:' + this.bindAttrs.join('|') + ')\\\\s*=\\\\s*(?:\"(.*)\"|\\'(.*)\\')|\\\\$\\\\{(.*)\\\\})',\r\n            bindingsRegex = new RegExp(bindingsPattern, 'g'),\r\n            keyOptions = [],\r\n            boundExpr, keyOption;\r\n\r\n        while(boundExpr = bindingsRegex.exec(html)) {\r\n\r\n            keyOption = KEY_VALUE_REGEXP_T.exec(boundExpr[1]);\r\n\r\n            if (keyOption) {\r\n                keyOptions.push(keyOption.slice(1));\r\n            }\r\n\r\n        }\r\n\r\n        return this.parseKeyOptions(keyOptions, path);\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param window          a jsdom window\r\n     * @param $               jquery\r\n     * @returns {Array}       extracted keys\r\n     */\r\n    parseDOM(window,$){\r\n        $ = $(window);\r\n        var keys = [];\r\n        var selector = `[${this.translationAttribute}]`;\r\n        var nodes = $(selector);\r\n\r\n        nodes.each(i=>{\r\n            var node = nodes.eq(i);\r\n            var value,key,m;\r\n\r\n            key = node.attr(this.translationAttribute);\r\n\r\n            var attr = \"text\";\r\n            //set default attribute to src if this is an image node\r\n            if(node[0].nodeName===\"IMG\") attr = \"src\";\r\n\r\n            var re = /\\[([a-z]*)]/g;\r\n            //check if a attribute was specified in the key\r\n            while ((m = re.exec(key)) !== null) {\r\n                if (m.index === re.lastIndex) {\r\n                    re.lastIndex++;\r\n                }\r\n                if(m){\r\n                    key = key.replace(m[0],'');\r\n                    attr = m[1];\r\n                }\r\n            }\r\n\r\n            switch(node[0].nodeName){\r\n                case \"IMG\":\r\n                    value = node.attr(this.imageAttribute);\r\n                    break;\r\n                default:\r\n                    switch(attr){\r\n                        case 'text':\r\n                            value = node.text().trim();\r\n                            break;\r\n                        case 'prepend':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'append':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'html':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        default: //custom attribute\r\n                            value = node.attr(attr);\r\n                            break;\r\n                    }\r\n            }\r\n\r\n            //skip keys with interpolations\r\n            if(key.indexOf(\"${\") > -1){\r\n                return;\r\n            }\r\n\r\n            // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            // remove the optional attribute\r\n            key = key.replace(/\\[[a-z]*]/g, '');\r\n\r\n            if(!key) key = value;\r\n            keys.push(key);\r\n            this.values[key] = value;\r\n            this.nodes[key] = node;\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n    /**\r\n     * Parse and add keys to the registry.\r\n     * @param keys\r\n     */\r\n    addToRegistry(keys){\r\n        for(let key of keys){\r\n        // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            if(key.indexOf(this.namespaceSeparator) === -1){\r\n                key = this.defaultNamespace + this.keySeparator + key;\r\n            }else{\r\n                key = key.replace(this.namespaceSeparator, this.keySeparator);\r\n            }\r\n\r\n            this.registry.push(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate translation files from the current registry entries.\r\n     *\r\n     * @param locale\r\n     */\r\n    generateTranslation(locale){\r\n\r\n        var mergedTranslations, currentTranslations, oldTranslations, key;\r\n\r\n        this.registryHash = {};\r\n\r\n        // turn the array of keys\r\n        // into an associative object\r\n        // ==========================\r\n        for(var i = 0, l = this.registry.length; i < l; i++){\r\n            key = this.registry[i];\r\n            this.registryHash = hashFromString(key, '', this.keySeparator, this.registryHash);\r\n        }\r\n\r\n        for(var namespace in this.registryHash){\r\n            if(!this.registryHash.hasOwnProperty(namespace)) continue;\r\n\r\n            // get previous version of the files\r\n            var namespacePath = namespace + '.json';\r\n            //var namespaceOldPath = namespace + '_old.json';\r\n\r\n            var basePath = this.localesPath+\"/\"+locale+\"/\";\r\n            if(this.verbose) gutil.log('basePath', basePath);\r\n\r\n            if(fs.existsSync(basePath+namespacePath)){\r\n                try{\r\n                    currentTranslations = JSON.parse(fs.readFileSync(basePath+namespacePath));\r\n                }catch(error){\r\n                    this.emit('json_error', error.name, error.message);\r\n                    currentTranslations = {};\r\n                }\r\n            }else{\r\n                currentTranslations = {};\r\n            }\r\n\r\n            //if(fs.existsSync(basePath+namespaceOldPath)){\r\n            //  try{\r\n            //    oldTranslations = JSON.parse(fs.readFileSync(basePath+namespaceOldPath));\r\n            //  }\r\n            //  catch(error){\r\n            //    this.emit('json_error', error.name, error.message);\r\n            //    currentTranslations = {};\r\n            //  }\r\n            //}\r\n            //else{\r\n            //  oldTranslations = {};\r\n            //}\r\n\r\n            oldTranslations = {};\r\n\r\n            // merges existing translations with the new ones\r\n            mergedTranslations = mergeHash(currentTranslations, Object.assign({}, this.registryHash[namespace]));\r\n\r\n            // restore old translations if the key is empty\r\n            mergedTranslations.new = replaceEmpty(oldTranslations, mergedTranslations.new);\r\n\r\n            var transform = null;\r\n            //transform values found in the html to uppercase if this is not the default language\r\n            if(locale !== this.defaultLocale) transform = \"uppercase\";\r\n\r\n            mergedTranslations.new = this.getValuesFromHash(this.valuesHash, mergedTranslations.new,transform,this.nodesHash,this.valuesHash);\r\n\r\n            // merges former old translations with the new ones\r\n            mergedTranslations.old = _.extend(oldTranslations, mergedTranslations.new);\r\n\r\n            // push files back to the stream\r\n            var mergedTranslationsFile = new File({\r\n                path: locale+\"/\"+namespacePath,\r\n                //base: locale,\r\n                contents: new Buffer(JSON.stringify(mergedTranslations.new, null, 2))\r\n            });\r\n            //var mergedOldTranslationsFile = new File({\r\n            //  path: locale+\"/\"+namespaceOldPath,\r\n            //  //base: locale,\r\n            //  contents: new Buffer(JSON.stringify(mergedTranslations.old, null, 2))\r\n            //});\r\n\r\n            /*if(this.verbose){\r\n              gutil.log('writing', locale+\"/\"+namespacePath);\r\n              gutil.log('writing', locale+\"/\"+namespaceOldPath);\r\n            }*/\r\n\r\n            this.stream.push(mergedTranslationsFile);\r\n            //this.stream.push(mergedOldTranslationsFile);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Generate translations for all locales from the registry\r\n     */\r\n    generateAllTranslations(){\r\n        this.updateHashes();\r\n\r\n        if(this.verbose) {\r\n            gutil.log('extracted registry:');\r\n            gutil.log(this.registry);\r\n        }\r\n\r\n        for(var i = 0, l = this.locales.length; i < l; i++){\r\n            this.generateTranslation(this.locales[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from the Aurelia app.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    extractFromApp(){\r\n        return this.extractor.getNavFromRoutes(this.routesModuleId)\r\n         .then(navRoutes=>{\r\n             if(!navRoutes) return null;\r\n\r\n             for(var i = 0, l = navRoutes.length; i < l; i++){\r\n                 var item = navRoutes[i];\r\n                 this.values[item.i18n] = item.title;\r\n                 this.registry.push(this.defaultNamespace + this.keySeparator + item.i18n);\r\n             }\r\n\r\n             if(this.verbose){\r\n                 gutil.log('navRoutes found:');\r\n                 gutil.log(navRoutes)\r\n             }\r\n\r\n             return null;\r\n         });\r\n    }\r\n\r\n    /**\r\n     * Takes a `target` hash and replace its empty\r\n     * values with the `source` hash ones if they exist\r\n     *\r\n     * @param source\r\n     * @param target\r\n     * @param transform\r\n     * @param nodesHash\r\n     * @param valuesHash\r\n     * @returns {*|{}}\r\n     */\r\n    getValuesFromHash(source, target,transform,nodesHash,valuesHash){\r\n        target = target || {};\r\n\r\n        Object.keys(source).forEach((key)=>{\r\n\r\n            var node = null;\r\n            if(nodesHash) node = nodesHash[key];\r\n            var value;\r\n\r\n            if(target[key] !== undefined){\r\n                if(typeof source[key] === 'object'){\r\n                    target[key] = this.getValuesFromHash(source[key], target[key], transform, node,(valuesHash)? valuesHash[key] : valuesHash);\r\n                }else if(target[key] === ''){\r\n                    if(!node) {\r\n                        //try to find in values\r\n                        if(valuesHash)value = valuesHash[key];\r\n                        if(transform === \"uppercase\") value = transformText(value);\r\n                    }else{\r\n                        value = source[key];\r\n                        if(transform === \"uppercase\" && node[0].nodeName !== \"IMG\") value = transformText(value);\r\n                    }\r\n                    target[key] = value;\r\n                }\r\n            }\r\n        });\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Get the file extension from a filepath.\r\n     *\r\n     * @param path        path to analyze\r\n     * @returns {string}  the extracted file extension\r\n     */\r\n    getExtension(path){\r\n        return path.substr(path.lastIndexOf(\".\") + 1);\r\n    }\r\n\r\n    /**\r\n     * Update hashes.\r\n     */\r\n    updateHashes(){\r\n\r\n        this.translationsHash = {};\r\n        this.valuesHash = {};\r\n        this.nodesHash = {};\r\n\r\n        var key;\r\n\r\n        // remove duplicate keys\r\n        this.translations = _.uniq(this.translations).sort();\r\n\r\n        //create hash for values\r\n        for(key in this.values){\r\n            if(!this.values.hasOwnProperty(key)) continue;\r\n            this.valuesHash = hashFromString(key, this.values[key], this.keySeparator, this.valuesHash);\r\n        }\r\n        //create hash for nodes\r\n        for(key in this.nodes){\r\n            if(!this.nodes.hasOwnProperty(key)) continue;\r\n            this.nodesHash = hashFromString(key, this.nodes[key], this.keySeparator, this.nodesHash);\r\n        }\r\n    }\r\n\r\n    //--------- Steam functions\r\n\r\n    transformFile(file, encoding, cb) {\r\n\r\n        var data,path;\r\n\r\n        // we do not handle streams\r\n        if (file.isStream()) {\r\n            this.emit('error', new PluginError(PLUGIN_NAME, 'Streams are not supported!'));\r\n            return cb();\r\n        }\r\n\r\n        //read the file manually if a filepath was passed.\r\n        if(file.isNull()){\r\n            path = file.path;\r\n            if(file.stat.isDirectory()){\r\n                return cb();\r\n            }else if(path && fs.existsSync(path)){\r\n                data = fs.readFileSync(path);\r\n            }else{\r\n                this.emit(\"error\", new PluginError(PLUGIN_NAME, \"File has no content and is not readable\"));\r\n                return cb();\r\n            }\r\n        }\r\n\r\n        if (file.isBuffer()) {\r\n            path = file.path.replace(process.cwd()+\"/\",\"\");\r\n            data = file.contents.toString();\r\n        }\r\n\r\n        //skip if no data was found\r\n        if(!data) return cb();\r\n\r\n        data = this.parseTranslations(path,data).then(keys=>{\r\n            this.addToRegistry(keys);\r\n            // tell the stream engine that we are done with this file\r\n            cb();\r\n        });\r\n\r\n        // make sure the file goes through the next gulp plugin\r\n        //this.push(file);\r\n    }\r\n\r\n    flush(cb){\r\n        //extract values from the aurelia application where possible\r\n        if(this.extractor){\r\n            this.extractFromApp().then(()=>{\r\n                this.generateAllTranslations();\r\n                cb();\r\n            });\r\n        }else{\r\n            this.generateAllTranslations();\r\n            cb();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The main plugin function\r\n *\r\n * @param opts\r\n * @returns {Stream}\r\n */\r\nexport function parse(opts) {\r\n    return new Parser(opts).parse();\r\n}\r\n"]}