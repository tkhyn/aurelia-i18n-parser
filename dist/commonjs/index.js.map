{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;wBAAoB,UAAU;;;;wBACZ,WAAW;;;;sBACf,QAAQ;;;;0BACP,aAAa;;;;qBACV,OAAO;;;;sBACX,QAAQ;;;;uBAE4C,WAAW;;oBAC5D,MAAM;;;;qBACN,OAAO;;;;4BACG,iBAAiB;;sBAEzB,SAAS;;;;AAC5B,IAAI,OAAO,GAAG,oBAAO,OAAO,CAAC;;AAE7B,IAAI,WAAW,GAAG,sBAAM,WAAW,CAAC;;AAEpC,IAAM,WAAW,GAAG,qBAAqB,CAAC;;AAE1C,IAAM,UAAU,GAAG,IAAI,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAC7D,IAAM,gBAAgB,GAAG,IAAI,MAAM,CAAC,kFAAkF,CAAC,CAAC;AACxH,IAAM,kBAAkB,GAAG,IAAI,MAAM,CAAC,6CAA6C,CAAC,CAAA;;IAGvE,MAAM;AAsBJ,aAtBF,MAAM,CAsBH,IAAI,EAAC;8BAtBR,MAAM;;aAEf,OAAO,GAAG,KAAK;aACf,gBAAgB,GAAE,aAAa;aAC/B,SAAS,GAAG,CAAC,GAAG,CAAC;aACjB,kBAAkB,GAAG,GAAG;aACxB,oBAAoB,GAAG,WAAW;aAClC,cAAc,GAAG,UAAU;aAC3B,YAAY,GAAG,GAAG;aAClB,sBAAsB,GAAG,CAAC,2BAA2B,CAAC;aACtD,OAAO,GAAG,IAAI;aACd,WAAW,GAAG,aAAa;aAC3B,cAAc,GAAG,QAAQ;aACzB,OAAO,GAAG,CAAC,OAAO,CAAC;aACnB,aAAa,GAAG,IAAI;aACpB,gBAAgB,GAAG,SAAS;aAC5B,SAAS,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC;aAEtD,QAAQ,GAAG,EAAE;aACb,MAAM,GAAG,EAAE;aACX,KAAK,GAAG,EAAE;;AAGN,YAAG,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,EAAC,IAAI,CAAC,CAAC;;AAElC,YAAG,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,GAAG,+BAAiB,IAAI,CAAC,OAAO,CAAC,CAAC;KACpE;;iBA1BQ,MAAM;;eA4BV,iBAAE;AACH,mBAAO,IAAI,CAAC,MAAM,GAAG,sBAAQ,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;SAC1F;;;eASgB,2BAAC,IAAI,EAAC,IAAI,EAAC;AACxB,gBAAI,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;AAClC,oBAAO,GAAG;AACN,qBAAK,MAAM;AACP,wBAAG,IAAI,CAAC,OAAO,EAAE,sBAAM,GAAG,CAAC,aAAa,EAAC,IAAI,CAAC,CAAC;AAC/C,2BAAO,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAAA,AACtC;AACI,wBAAG,IAAI,CAAC,OAAO,EAAE,sBAAM,GAAG,CAAC,WAAW,EAAC,IAAI,CAAC,CAAC;AAC7C,2BAAO,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAAA,aAC/C;SACJ;;;eAOc,yBAAC,UAAU,EAAE,IAAI,EAAE;AAC9B,gBAAI,IAAI,GAAG,EAAE;gBACT,MAAM,GAAG,IAAI;gBACb,GAAG;gBAAE,OAAO,CAAC;;AAEjB,sBAAU,CAAC,OAAO,CAAC,UAAS,SAAS,EAAE;gDAElB,SAAS;;AAAzB,mBAAG;AAAE,uBAAO;;AAEb,oBAAI;AACA,uBAAG,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;;AAEtC,wBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;AAGf,wBAAI,OAAO,KAAK,SAAS,EAAE;AACvB,+BAAO;qBACV;;AAED,wBAAI,YAAY,GAAG,SAAS,CAAC;AAC7B,wBAAI;AACA,+BAAO,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;;AAEtC,4BAAI,OAAO,KAAK,IAAI,EAAE;AAIlB,gCAAI,IAAI,CAAC,gBAAgB,IAAI,cAAc,EAAE;AACzC,4CAAY,GAAG,OAAO,CAAC;AACvB,4CAAY,GAAG,IAAI,CAAC,GAAG,GAAG,YAAY,GAAG,GAAG,CAAC,CAAC;6BACjD;yBACJ,MAAM;AAEH,gCAAI,EAAE,CAAC;AACP,mCAAO,EAAE,GAAG,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;AACxC,oCAAI,EAAE,CAAC,CAAC,CAAC,IAAI,cAAc,EAAE;AACzB,gDAAY,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACrB,gDAAY,GAAG,IAAI,OAAK,YAAY,OAAI,CAAC;AACzC,0CAAM;iCACT;6BACJ;yBACJ;;AAED,4BAAI,YAAY,EAAE;AACd,kCAAM,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC;yBACrC;qBACJ,CAAC,OAAO,CAAC,EAAE;AACR,+BAAO,CAAC,IAAI,sCAAmC,YAAY,qBAAc,GAAG,mBAAa,IAAI,iBAAY,CAAC,CAAG,CAAC;qBACjH;iBACJ,CAAC,OAAO,CAAC,EAAE;AACR,2BAAO,CAAC,IAAI,4BAAyB,GAAG,mBAAa,IAAI,iBAAY,CAAC,CAAG,CAAC;iBAC7E;aAEJ,CAAC,CAAC;;AAEH,mBAAO,IAAI,CAAC;SACf;;;eASc,yBAAC,IAAI,EAAE,IAAI,EAAC;AACvB,gBAAI,SAAS,GAAG,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC;AACrF,gBAAI,OAAO,GAAG,kBAAkB,GAAE,SAAS,GAAE,WAAW,CAAC;AACzD,gBAAI,aAAa,GAAG,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;;AAE7C,gBAAI,OAAO,EAAE,SAAS,CAAC;AACvB,gBAAI,UAAU,GAAG,EAAE,CAAC;;AAEpB,mBAAO,OAAO,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAEvC,oBAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AACpB,wBAAI,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;AAC3B,wBAAI,aAAa,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;AAChD,wBAAI,CAAC,IAAI,CAAC,sBAAsB,IAAI,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,UAAS,IAAI,EAAE;AAAC,+BAAO,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;qBAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;;AAE7I,iCAAS,GAAG,SAAS,CAAC,KAAK,CAAE,YAAY,CAAC,CAAC;;AAE3C,4BAAI,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE;AAC3B,sCAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;yBAC9B;qBACJ;iBACJ;aACJ;;AAED,mBAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;SAClE;;;eAQQ,mBAAC,IAAI,EAAE,IAAI,EAAC;;;AACjB,mBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAI;AACnC,mCAAM,GAAG,CAAC;AACN,wBAAI,EAAE,IAAI;AACV,wBAAI,EAAE,cAAC,MAAM,EAAE,MAAM,EAAG;AACpB,4BAAG,MAAM,EAAC;AAEN,kDAAM,GAAG,CAAC,MAAM,CAAC,CAAC;AAClB,kCAAM,CAAC,MAAM,CAAC,CAAC;AACf,mCAAO;yBACV;AACD,+BAAO,CAAC,MAAK,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAC/C,+BAAO,CAAC,MAAK,QAAQ,CAAC,MAAM,sBAAG,CAAC,CAAC;qBACpC;iBACJ,CAAC,CAAC;aACN,CAAC,CAAC;SACN;;;eASmB,8BAAC,IAAI,EAAE,IAAI,EAAE;;AAE7B,gBAAI,eAAe,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,8CAA8C;gBACzG,aAAa,GAAG,IAAI,MAAM,CAAC,eAAe,EAAE,GAAG,CAAC;gBAChD,UAAU,GAAG,EAAE;gBACf,SAAS;gBAAE,SAAS,CAAC;;AAEzB,mBAAM,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;;AAExC,yBAAS,GAAG,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;;AAElD,oBAAI,SAAS,EAAE;AACX,8BAAU,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;iBACvC;aAEJ;;AAED,mBAAO,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;SACjD;;;eASO,kBAAC,MAAM,EAAC,CAAC,EAAC;;;AACd,aAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;AACd,gBAAI,IAAI,GAAG,EAAE,CAAC;AACd,gBAAI,QAAQ,SAAO,IAAI,CAAC,oBAAoB,MAAG,CAAC;AAChD,gBAAI,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;;AAExB,iBAAK,CAAC,IAAI,CAAC,UAAA,CAAC,EAAE;AACV,oBAAI,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACvB,oBAAI,KAAK,EAAC,GAAG,EAAC,CAAC,CAAC;;AAEhB,mBAAG,GAAG,IAAI,CAAC,IAAI,CAAC,OAAK,oBAAoB,CAAC,CAAC;;AAE3C,oBAAI,IAAI,GAAG,MAAM,CAAC;;AAElB,oBAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAG,KAAK,EAAE,IAAI,GAAG,KAAK,CAAC;;AAE1C,oBAAI,EAAE,GAAG,cAAc,CAAC;;AAExB,uBAAO,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,KAAM,IAAI,EAAE;AAChC,wBAAI,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC,SAAS,EAAE;AAC1B,0BAAE,CAAC,SAAS,EAAE,CAAC;qBAClB;AACD,wBAAG,CAAC,EAAC;AACD,2BAAG,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAC,EAAE,CAAC,CAAC;AAC3B,4BAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;qBACf;iBACJ;;AAED,wBAAO,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ;AACnB,yBAAK,KAAK;AACN,6BAAK,GAAG,IAAI,CAAC,IAAI,CAAC,OAAK,cAAc,CAAC,CAAC;AACvC,8BAAM;AAAA,AACV;AACI,gCAAO,IAAI;AACP,iCAAK,MAAM;AACP,qCAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAC3B,sCAAM;AAAA,AACV,iCAAK,SAAS;AACV,qCAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAC3B,sCAAM;AAAA,AACV,iCAAK,QAAQ;AACT,qCAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAC3B,sCAAM;AAAA,AACV,iCAAK,MAAM;AACP,qCAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAC3B,sCAAM;AAAA,AACV;AACI,qCAAK,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACxB,sCAAM;AAAA,yBACb;AAAA,iBACR;;AAGD,oBAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAC;AACtB,2BAAO;iBACV;;AAGD,mBAAG,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;;AAGpC,mBAAG,GAAG,GAAG,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;;AAEpC,oBAAG,CAAC,GAAG,EAAE,GAAG,GAAG,KAAK,CAAC;AACrB,oBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,uBAAK,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AACzB,uBAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;aAC1B,CAAC,CAAC;;AAEH,mBAAO,IAAI,CAAC;SACf;;;eAMY,uBAAC,IAAI,EAAC;;;;;;AACf,qCAAe,IAAI,8HAAC;wBAAZ,GAAG;;AAEP,uBAAG,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;;AAEpC,wBAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAC;AAC3C,2BAAG,GAAG,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC;qBACzD,MAAI;AACD,2BAAG,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;qBACjE;;AAED,wBAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBAC3B;;;;;;;;;;;;;;;SACJ;;;eAOkB,6BAAC,MAAM,EAAC;;AAEvB,gBAAI,kBAAkB,EAAE,mBAAmB,EAAE,eAAe,EAAE,GAAG,CAAC;;AAElE,gBAAI,CAAC,YAAY,GAAG,EAAE,CAAC;;AAKvB,iBAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAC;AAChD,mBAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AACvB,oBAAI,CAAC,YAAY,GAAG,6BAAe,GAAG,EAAE,EAAE,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;aACrF;;AAED,iBAAI,IAAI,SAAS,IAAI,IAAI,CAAC,YAAY,EAAC;AACnC,oBAAG,CAAC,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,SAAS;;AAG1D,oBAAI,aAAa,GAAG,SAAS,GAAG,OAAO,CAAC;;AAGxC,oBAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,GAAC,GAAG,GAAC,MAAM,GAAC,GAAG,CAAC;AAC/C,oBAAG,IAAI,CAAC,OAAO,EAAE,sBAAM,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;;AAEjD,oBAAG,wBAAG,UAAU,CAAC,QAAQ,GAAC,aAAa,CAAC,EAAC;AACrC,wBAAG;AACC,2CAAmB,GAAG,IAAI,CAAC,KAAK,CAAC,wBAAG,YAAY,CAAC,QAAQ,GAAC,aAAa,CAAC,CAAC,CAAC;qBAC7E,CAAA,OAAM,KAAK,EAAC;AACT,4BAAI,CAAC,IAAI,CAAC,YAAY,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;AACnD,2CAAmB,GAAG,EAAE,CAAC;qBAC5B;iBACJ,MAAI;AACD,uCAAmB,GAAG,EAAE,CAAC;iBAC5B;;AAeD,+BAAe,GAAG,EAAE,CAAC;;AAGrB,kCAAkB,GAAG,wBAAU,mBAAmB,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;;AAGrG,kCAAkB,OAAI,GAAG,2BAAa,eAAe,EAAE,kBAAkB,OAAI,CAAC,CAAC;;AAE/E,oBAAI,SAAS,GAAG,IAAI,CAAC;;AAErB,oBAAG,MAAM,KAAK,IAAI,CAAC,aAAa,EAAE,SAAS,GAAG,WAAW,CAAC;;AAE1D,kCAAkB,OAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,EAAE,kBAAkB,OAAI,EAAC,SAAS,EAAC,IAAI,CAAC,SAAS,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC;;AAGlI,kCAAkB,CAAC,GAAG,GAAG,oBAAE,MAAM,CAAC,eAAe,EAAE,kBAAkB,OAAI,CAAC,CAAC;;AAG3E,oBAAI,sBAAsB,GAAG,uBAAS;AAClC,wBAAI,EAAE,MAAM,GAAC,GAAG,GAAC,aAAa;;AAE9B,4BAAQ,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,kBAAkB,OAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;iBACxE,CAAC,CAAC;;AAYH,oBAAI,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;aAE5C;SAEJ;;;eAKsB,mCAAE;AACrB,gBAAI,CAAC,YAAY,EAAE,CAAC;;AAEpB,gBAAG,IAAI,CAAC,OAAO,EAAE;AACb,sCAAM,GAAG,CAAC,qBAAqB,CAAC,CAAC;AACjC,sCAAM,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC5B;;AAED,iBAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAC;AAC/C,oBAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;aAC7C;SACJ;;;eAOa,0BAAE;;;AACZ,mBAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CACzD,IAAI,CAAC,UAAA,SAAS,EAAE;AACb,oBAAG,CAAC,SAAS,EAAE,OAAO,IAAI,CAAC;;AAE3B,qBAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAC;AAC5C,wBAAI,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AACxB,2BAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;AACpC,2BAAK,QAAQ,CAAC,IAAI,CAAC,OAAK,gBAAgB,GAAG,OAAK,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC7E;;AAED,oBAAG,OAAK,OAAO,EAAC;AACZ,0CAAM,GAAG,CAAC,kBAAkB,CAAC,CAAC;AAC9B,0CAAM,GAAG,CAAC,SAAS,CAAC,CAAA;iBACvB;;AAED,uBAAO,IAAI,CAAC;aACf,CAAC,CAAC;SACP;;;eAagB,2BAAC,MAAM,EAAE,MAAM,EAAC,SAAS,EAAC,SAAS,EAAC,UAAU,EAAC;;;AAC5D,kBAAM,GAAG,MAAM,IAAI,EAAE,CAAC;;AAEtB,kBAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG,EAAG;;AAE/B,oBAAI,IAAI,GAAG,IAAI,CAAC;AAChB,oBAAG,SAAS,EAAE,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;AACpC,oBAAI,KAAK,CAAC;;AAEV,oBAAG,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS,EAAC;AACzB,wBAAG,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAC;AAC/B,8BAAM,CAAC,GAAG,CAAC,GAAG,OAAK,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,IAAI,EAAC,AAAC,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC;qBAC9H,MAAK,IAAG,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,EAAC;AACxB,4BAAG,CAAC,IAAI,EAAE;AAEN,gCAAG,UAAU,EAAC,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;AACtC,gCAAG,SAAS,KAAK,WAAW,EAAE,KAAK,GAAG,4BAAc,KAAK,CAAC,CAAC;yBAC9D,MAAI;AACD,iCAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AACpB,gCAAG,SAAS,KAAK,WAAW,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,KAAK,EAAE,KAAK,GAAG,4BAAc,KAAK,CAAC,CAAC;yBAC5F;AACD,8BAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;qBACvB;iBACJ;aACJ,CAAC,CAAC;;AAEH,mBAAO,MAAM,CAAC;SACjB;;;eAQW,sBAAC,IAAI,EAAC;AACd,mBAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;SACjD;;;eAKW,wBAAE;;AAEV,gBAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;AAC3B,gBAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AACrB,gBAAI,CAAC,SAAS,GAAG,EAAE,CAAC;;AAEpB,gBAAI,GAAG,CAAC;;AAGR,gBAAI,CAAC,YAAY,GAAG,oBAAE,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,IAAI,EAAE,CAAC;;AAGrD,iBAAI,GAAG,IAAI,IAAI,CAAC,MAAM,EAAC;AACnB,oBAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,SAAS;AAC9C,oBAAI,CAAC,UAAU,GAAG,6BAAe,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;aAC/F;;AAED,iBAAI,GAAG,IAAI,IAAI,CAAC,KAAK,EAAC;AAClB,oBAAG,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,SAAS;AAC7C,oBAAI,CAAC,SAAS,GAAG,6BAAe,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;aAC5F;SACJ;;;eAIY,uBAAC,IAAI,EAAE,QAAQ,EAAE,EAAE,EAAE;;;AAE9B,gBAAI,IAAI,EAAC,IAAI,CAAC;;AAGd,gBAAI,IAAI,CAAC,QAAQ,EAAE,EAAE;AACjB,oBAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,WAAW,CAAC,WAAW,EAAE,4BAA4B,CAAC,CAAC,CAAC;AAC/E,uBAAO,EAAE,EAAE,CAAC;aACf;;AAGD,gBAAG,IAAI,CAAC,MAAM,EAAE,EAAC;AACb,oBAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACjB,oBAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,EAAC;AACvB,2BAAO,EAAE,EAAE,CAAC;iBACf,MAAK,IAAG,IAAI,IAAI,wBAAG,UAAU,CAAC,IAAI,CAAC,EAAC;AACjC,wBAAI,GAAG,wBAAG,YAAY,CAAC,IAAI,CAAC,CAAC;iBAChC,MAAI;AACD,wBAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,WAAW,CAAC,WAAW,EAAE,yCAAyC,CAAC,CAAC,CAAC;AAC5F,2BAAO,EAAE,EAAE,CAAC;iBACf;aACJ;;AAED,gBAAI,IAAI,CAAC,QAAQ,EAAE,EAAE;AACjB,oBAAI,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,GAAC,GAAG,EAAC,EAAE,CAAC,CAAC;AAC/C,oBAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;aACnC;;AAGD,gBAAG,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE,CAAC;;AAEtB,gBAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAA,IAAI,EAAE;AAChD,uBAAK,aAAa,CAAC,IAAI,CAAC,CAAC;;AAEzB,kBAAE,EAAE,CAAC;aACR,CAAC,CAAC;SAIN;;;eAEI,eAAC,EAAE,EAAC;;;AAEL,gBAAG,IAAI,CAAC,SAAS,EAAC;AACd,oBAAI,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,YAAI;AAC3B,2BAAK,uBAAuB,EAAE,CAAC;AAC/B,sBAAE,EAAE,CAAC;iBACR,CAAC,CAAC;aACN,MAAI;AACD,oBAAI,CAAC,uBAAuB,EAAE,CAAC;AAC/B,kBAAE,EAAE,CAAC;aACR;SACJ;;;WAjjBQ,MAAM;;;;;AA0jBZ,SAAS,KAAK,CAAC,IAAI,EAAE;AACxB,WAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;CACnC","file":"index.js","sourceRoot":"/source/","sourcesContent":["import through from 'through2';\r\nimport gutil from \"gulp-util\";\r\nimport _ from \"lodash\";\r\nimport fs from \"graceful-fs\";\r\nimport jsdom from \"jsdom\";\r\nimport $ from \"jquery\";\r\n\r\nimport {hashFromString,mergeHash,replaceEmpty,transformText} from \"./helpers\";\r\nimport path from \"path\";\r\nimport File from \"vinyl\";\r\nimport {AppExtractor} from \"./app-extractor\";\r\n\r\nimport corejs from \"core-js\";\r\nvar Promise = corejs.Promise;\r\n\r\nvar PluginError = gutil.PluginError;\r\n\r\nconst PLUGIN_NAME = \"aurelia-i18n-parser\";\r\n\r\nconst OBJ_REGEXP = new RegExp(/^\\s*\\{\\s*([\\s\\S]*)\\s*\\}\\s*$/);\r\nconst KEY_VALUE_REGEXP = new RegExp(/\\s*['\"]?([\\w]*)['\"]?\\s*:\\s*(\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]|[^,]*)\\s*,?\\s*(?=$|[\"'\\w]+)/g);\r\nconst KEY_VALUE_REGEXP_T = new RegExp(/('.*'|\".*\")\\s*\\|\\s*t\\s*:\\s*(.*?)\\s*(?:\\||$)/)\r\n\r\n\r\nexport class Parser{\r\n\r\n    verbose = false;\r\n    defaultNamespace ='translation';\r\n    functions = ['t'];\r\n    namespaceSeparator = \":\";\r\n    translationAttribute = \"data-i18n\";\r\n    imageAttribute = \"data-src\";\r\n    keySeparator = \".\";\r\n    functionsParamsExclude = ['key: string, options: any'];\r\n    appPath = null;\r\n    localesPath = \"src/locales\";\r\n    routesModuleId = \"routes\";\r\n    locales = ['en-US'];\r\n    defaultLocale = \"en\";\r\n    shortcutFunction = 'sprintf';\r\n    bindAttrs = ['bind', 'one-way', 'two-way', 'one-time'];\r\n\r\n    registry = [];\r\n    values = {};\r\n    nodes = {};\r\n\r\n    constructor(opts){\r\n        if(opts) Object.assign(this,opts);\r\n\r\n        if(this.appPath) this.extractor = new AppExtractor(this.appPath);\r\n    }\r\n\r\n    parse(){\r\n        return this.stream = through.obj(this.transformFile.bind(this), this.flush.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Figures out how to parse the data based on file extension.\r\n     *\r\n     * @param path          path to the file\r\n     * @param data          data of the file\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseTranslations(path,data){\r\n        var ext = this.getExtension(path);\r\n        switch(ext){\r\n            case 'html':\r\n                if(this.verbose) gutil.log(\"parse HTML:\",path);\r\n                return this.parseHTML(data, path);\r\n            default:\r\n                if(this.verbose) gutil.log(\"parse JS:\",path);\r\n                return this.parseJavaScript(data, path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from an array of (key, options) strings\r\n     * @returns {Array}     the extracted translation keys\r\n     */\r\n\r\n    parseKeyOptions(keyOptions, path) {\r\n        var keys = [],\r\n            _this2 = this,\r\n            key, options;\r\n\r\n        keyOptions.forEach(function(keyOption) {\r\n\r\n            [key, options] = keyOption;\r\n\r\n            try {\r\n                key = eval(key.replace(/this./g, ''));\r\n\r\n                keys.push(key);\r\n\r\n                // try and extract default value from options\r\n                if (options === undefined) {\r\n                    return;\r\n                }\r\n\r\n                var defaultValue = undefined;\r\n                try {\r\n                    options = OBJ_REGEXP.exec(options)[1];\r\n\r\n                    if (options === null) {\r\n                        // we have a single value, possibly because\r\n                        // i18next is used with shortcutFunction: 'defaultValue'\r\n                        // and 'options' is a string that should be evaluated\r\n                        if (this.shortcutFunction == 'defaultValue') {\r\n                            defaultValue = options;\r\n                            defaultValue = eval('(' + defaultValue + ')');\r\n                        }\r\n                    } else {\r\n                        // options is an object, parse the keys\r\n                        var kv;\r\n                        while (kv = KEY_VALUE_REGEXP.exec(options)) {\r\n                            if (kv[1] == 'defaultValue') {\r\n                                defaultValue = kv[2];\r\n                                defaultValue = eval(`(${defaultValue})`);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (defaultValue) {\r\n                        _this2.values[key] = defaultValue;\r\n                    }\r\n                } catch (e) {\r\n                    console.warn(`Unable to parse default value \"${defaultValue}\" for key \"${key}\" in file ${path}. Error: ${e}`);\r\n                }\r\n            } catch (e) {\r\n                console.warn(`Unable to parse key \"${key}\" in file ${path}. Error: ${e}`);\r\n            }\r\n\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    /**\r\n     * Extract translations from javascript code.\r\n     *\r\n     * @param data          javascript code as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseJavaScript(data, path){\r\n        var fnPattern = '(?:' + this.functions.join('\\\\()|(?:').replace('.', '\\\\.') + '\\\\()';\r\n        var pattern = '[^a-zA-Z0-9_](?:'+ fnPattern +')([^);]*)';\r\n        var functionRegex = new RegExp(pattern, 'g');\r\n\r\n        var matches, keyOption;\r\n        var keyOptions = [];\r\n\r\n        while( matches = functionRegex.exec(data) ){\r\n            // parameters pairs are always in third element of matches array\r\n            if (matches.length > 1) {\r\n                var argsMatch = matches[1]; //replace spaces with empty\r\n                var argsMatchTrim = argsMatch.replace(/ /g, '');\r\n                if (!this.functionsParamsExclude || this.functionsParamsExclude.map(function(item) {return item.replace(/ /g, '');}).indexOf(argsMatchTrim) < 0) {\r\n\r\n                    keyOption = argsMatch.split( /,([\\s\\S]+)/);\r\n\r\n                    if (keyOption && keyOption[0]) {\r\n                        keyOptions.push(keyOption);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.resolve(this.parseKeyOptions(keyOptions, path));\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param data          html markup as a string\r\n     * @returns {Promise}   resolved when data has been parsed\r\n     */\r\n    parseHTML(data, path){\r\n        return new Promise((resolve, reject) =>{\r\n            jsdom.env({\r\n                html: data,\r\n                done: (errors, window)=>{\r\n                    if(errors){\r\n                        //throw new new PluginError(PLUGIN_NAME, 'Streams are not supported!');\r\n                        gutil.log(errors);\r\n                        reject(errors);\r\n                        return;\r\n                    }\r\n                    resolve(this.parseAureliaBindings(data, path));\r\n                    resolve(this.parseDOM(window,$));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Extract translations from aurelia bindnigs.\r\n    *\r\n    * @param window          a jsdom window\r\n    * @param $               jquery\r\n    * @returns {Array}       extracted keys\r\n    */\r\n    parseAureliaBindings(html, path) {\r\n\r\n        var bindingsPattern = '(?:\\\\.(?:' + this.bindAttrs.join('|') + ')\\\\s*=\\\\s*(?:\"(.*)\"|\\'(.*)\\')|\\\\$\\\\{(.*)\\\\})',\r\n            bindingsRegex = new RegExp(bindingsPattern, 'g'),\r\n            keyOptions = [],\r\n            boundExpr, keyOption;\r\n\r\n        while(boundExpr = bindingsRegex.exec(html)) {\r\n\r\n            keyOption = KEY_VALUE_REGEXP_T.exec(boundExpr[1]);\r\n\r\n            if (keyOption) {\r\n                keyOptions.push(keyOption.slice(1));\r\n            }\r\n\r\n        }\r\n\r\n        return this.parseKeyOptions(keyOptions, path);\r\n    }\r\n\r\n    /**\r\n     * Extract translations from html markup.\r\n     *\r\n     * @param window          a jsdom window\r\n     * @param $               jquery\r\n     * @returns {Array}       extracted keys\r\n     */\r\n    parseDOM(window,$){\r\n        $ = $(window);\r\n        var keys = [];\r\n        var selector = `[${this.translationAttribute}]`;\r\n        var nodes = $(selector);\r\n\r\n        nodes.each(i=>{\r\n            var node = nodes.eq(i);\r\n            var value,key,m;\r\n\r\n            key = node.attr(this.translationAttribute);\r\n\r\n            var attr = \"text\";\r\n            //set default attribute to src if this is an image node\r\n            if(node[0].nodeName===\"IMG\") attr = \"src\";\r\n\r\n            var re = /\\[([a-z]*)]/g;\r\n            //check if a attribute was specified in the key\r\n            while ((m = re.exec(key)) !== null) {\r\n                if (m.index === re.lastIndex) {\r\n                    re.lastIndex++;\r\n                }\r\n                if(m){\r\n                    key = key.replace(m[0],'');\r\n                    attr = m[1];\r\n                }\r\n            }\r\n\r\n            switch(node[0].nodeName){\r\n                case \"IMG\":\r\n                    value = node.attr(this.imageAttribute);\r\n                    break;\r\n                default:\r\n                    switch(attr){\r\n                        case 'text':\r\n                            value = node.text().trim();\r\n                            break;\r\n                        case 'prepend':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'append':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        case 'html':\r\n                            value = node.html().trim();\r\n                            break;\r\n                        default: //custom attribute\r\n                            value = node.attr(attr);\r\n                            break;\r\n                    }\r\n            }\r\n\r\n            //skip keys with interpolations\r\n            if(key.indexOf(\"${\") > -1){\r\n                return;\r\n            }\r\n\r\n            // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            // remove the optional attribute\r\n            key = key.replace(/\\[[a-z]*]/g, '');\r\n\r\n            if(!key) key = value;\r\n            keys.push(key);\r\n            this.values[key] = value;\r\n            this.nodes[key] = node;\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n    /**\r\n     * Parse and add keys to the registry.\r\n     * @param keys\r\n     */\r\n    addToRegistry(keys){\r\n        for(let key of keys){\r\n        // remove the backslash from escaped quotes\r\n            key = key.replace(/\\\\('|\")/g, '$1');\r\n\r\n            if(key.indexOf(this.namespaceSeparator) === -1){\r\n                key = this.defaultNamespace + this.keySeparator + key;\r\n            }else{\r\n                key = key.replace(this.namespaceSeparator, this.keySeparator);\r\n            }\r\n\r\n            this.registry.push(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate translation files from the current registry entries.\r\n     *\r\n     * @param locale\r\n     */\r\n    generateTranslation(locale){\r\n\r\n        var mergedTranslations, currentTranslations, oldTranslations, key;\r\n\r\n        this.registryHash = {};\r\n\r\n        // turn the array of keys\r\n        // into an associative object\r\n        // ==========================\r\n        for(var i = 0, l = this.registry.length; i < l; i++){\r\n            key = this.registry[i];\r\n            this.registryHash = hashFromString(key, '', this.keySeparator, this.registryHash);\r\n        }\r\n\r\n        for(var namespace in this.registryHash){\r\n            if(!this.registryHash.hasOwnProperty(namespace)) continue;\r\n\r\n            // get previous version of the files\r\n            var namespacePath = namespace + '.json';\r\n            //var namespaceOldPath = namespace + '_old.json';\r\n\r\n            var basePath = this.localesPath+\"/\"+locale+\"/\";\r\n            if(this.verbose) gutil.log('basePath', basePath);\r\n\r\n            if(fs.existsSync(basePath+namespacePath)){\r\n                try{\r\n                    currentTranslations = JSON.parse(fs.readFileSync(basePath+namespacePath));\r\n                }catch(error){\r\n                    this.emit('json_error', error.name, error.message);\r\n                    currentTranslations = {};\r\n                }\r\n            }else{\r\n                currentTranslations = {};\r\n            }\r\n\r\n            //if(fs.existsSync(basePath+namespaceOldPath)){\r\n            //  try{\r\n            //    oldTranslations = JSON.parse(fs.readFileSync(basePath+namespaceOldPath));\r\n            //  }\r\n            //  catch(error){\r\n            //    this.emit('json_error', error.name, error.message);\r\n            //    currentTranslations = {};\r\n            //  }\r\n            //}\r\n            //else{\r\n            //  oldTranslations = {};\r\n            //}\r\n\r\n            oldTranslations = {};\r\n\r\n            // merges existing translations with the new ones\r\n            mergedTranslations = mergeHash(currentTranslations, Object.assign({}, this.registryHash[namespace]));\r\n\r\n            // restore old translations if the key is empty\r\n            mergedTranslations.new = replaceEmpty(oldTranslations, mergedTranslations.new);\r\n\r\n            var transform = null;\r\n            //transform values found in the html to uppercase if this is not the default language\r\n            if(locale !== this.defaultLocale) transform = \"uppercase\";\r\n\r\n            mergedTranslations.new = this.getValuesFromHash(this.valuesHash, mergedTranslations.new,transform,this.nodesHash,this.valuesHash);\r\n\r\n            // merges former old translations with the new ones\r\n            mergedTranslations.old = _.extend(oldTranslations, mergedTranslations.new);\r\n\r\n            // push files back to the stream\r\n            var mergedTranslationsFile = new File({\r\n                path: locale+\"/\"+namespacePath,\r\n                //base: locale,\r\n                contents: new Buffer(JSON.stringify(mergedTranslations.new, null, 2))\r\n            });\r\n            //var mergedOldTranslationsFile = new File({\r\n            //  path: locale+\"/\"+namespaceOldPath,\r\n            //  //base: locale,\r\n            //  contents: new Buffer(JSON.stringify(mergedTranslations.old, null, 2))\r\n            //});\r\n\r\n            /*if(this.verbose){\r\n              gutil.log('writing', locale+\"/\"+namespacePath);\r\n              gutil.log('writing', locale+\"/\"+namespaceOldPath);\r\n            }*/\r\n\r\n            this.stream.push(mergedTranslationsFile);\r\n            //this.stream.push(mergedOldTranslationsFile);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Generate translations for all locales from the registry\r\n     */\r\n    generateAllTranslations(){\r\n        this.updateHashes();\r\n\r\n        if(this.verbose) {\r\n            gutil.log('extracted registry:');\r\n            gutil.log(this.registry);\r\n        }\r\n\r\n        for(var i = 0, l = this.locales.length; i < l; i++){\r\n            this.generateTranslation(this.locales[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract translations from the Aurelia app.\r\n     *\r\n     * @returns {Promise}\r\n     */\r\n    extractFromApp(){\r\n        return this.extractor.getNavFromRoutes(this.routesModuleId)\r\n         .then(navRoutes=>{\r\n             if(!navRoutes) return null;\r\n\r\n             for(var i = 0, l = navRoutes.length; i < l; i++){\r\n                 var item = navRoutes[i];\r\n                 this.values[item.i18n] = item.title;\r\n                 this.registry.push(this.defaultNamespace + this.keySeparator + item.i18n);\r\n             }\r\n\r\n             if(this.verbose){\r\n                 gutil.log('navRoutes found:');\r\n                 gutil.log(navRoutes)\r\n             }\r\n\r\n             return null;\r\n         });\r\n    }\r\n\r\n    /**\r\n     * Takes a `target` hash and replace its empty\r\n     * values with the `source` hash ones if they exist\r\n     *\r\n     * @param source\r\n     * @param target\r\n     * @param transform\r\n     * @param nodesHash\r\n     * @param valuesHash\r\n     * @returns {*|{}}\r\n     */\r\n    getValuesFromHash(source, target,transform,nodesHash,valuesHash){\r\n        target = target || {};\r\n\r\n        Object.keys(source).forEach((key)=>{\r\n\r\n            var node = null;\r\n            if(nodesHash) node = nodesHash[key];\r\n            var value;\r\n\r\n            if(target[key] !== undefined){\r\n                if(typeof source[key] === 'object'){\r\n                    target[key] = this.getValuesFromHash(source[key], target[key], transform, node,(valuesHash)? valuesHash[key] : valuesHash);\r\n                }else if(target[key] === ''){\r\n                    if(!node) {\r\n                        //try to find in values\r\n                        if(valuesHash)value = valuesHash[key];\r\n                        if(transform === \"uppercase\") value = transformText(value);\r\n                    }else{\r\n                        value = source[key];\r\n                        if(transform === \"uppercase\" && node[0].nodeName !== \"IMG\") value = transformText(value);\r\n                    }\r\n                    target[key] = value;\r\n                }\r\n            }\r\n        });\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Get the file extension from a filepath.\r\n     *\r\n     * @param path        path to analyze\r\n     * @returns {string}  the extracted file extension\r\n     */\r\n    getExtension(path){\r\n        return path.substr(path.lastIndexOf(\".\") + 1);\r\n    }\r\n\r\n    /**\r\n     * Update hashes.\r\n     */\r\n    updateHashes(){\r\n\r\n        this.translationsHash = {};\r\n        this.valuesHash = {};\r\n        this.nodesHash = {};\r\n\r\n        var key;\r\n\r\n        // remove duplicate keys\r\n        this.translations = _.uniq(this.translations).sort();\r\n\r\n        //create hash for values\r\n        for(key in this.values){\r\n            if(!this.values.hasOwnProperty(key)) continue;\r\n            this.valuesHash = hashFromString(key, this.values[key], this.keySeparator, this.valuesHash);\r\n        }\r\n        //create hash for nodes\r\n        for(key in this.nodes){\r\n            if(!this.nodes.hasOwnProperty(key)) continue;\r\n            this.nodesHash = hashFromString(key, this.nodes[key], this.keySeparator, this.nodesHash);\r\n        }\r\n    }\r\n\r\n    //--------- Steam functions\r\n\r\n    transformFile(file, encoding, cb) {\r\n\r\n        var data,path;\r\n\r\n        // we do not handle streams\r\n        if (file.isStream()) {\r\n            this.emit('error', new PluginError(PLUGIN_NAME, 'Streams are not supported!'));\r\n            return cb();\r\n        }\r\n\r\n        //read the file manually if a filepath was passed.\r\n        if(file.isNull()){\r\n            path = file.path;\r\n            if(file.stat.isDirectory()){\r\n                return cb();\r\n            }else if(path && fs.existsSync(path)){\r\n                data = fs.readFileSync(path);\r\n            }else{\r\n                this.emit(\"error\", new PluginError(PLUGIN_NAME, \"File has no content and is not readable\"));\r\n                return cb();\r\n            }\r\n        }\r\n\r\n        if (file.isBuffer()) {\r\n            path = file.path.replace(process.cwd()+\"/\",\"\");\r\n            data = file.contents.toString();\r\n        }\r\n\r\n        //skip if no data was found\r\n        if(!data) return cb();\r\n\r\n        data = this.parseTranslations(path,data).then(keys=>{\r\n            this.addToRegistry(keys);\r\n            // tell the stream engine that we are done with this file\r\n            cb();\r\n        });\r\n\r\n        // make sure the file goes through the next gulp plugin\r\n        //this.push(file);\r\n    }\r\n\r\n    flush(cb){\r\n        //extract values from the aurelia application where possible\r\n        if(this.extractor){\r\n            this.extractFromApp().then(()=>{\r\n                this.generateAllTranslations();\r\n                cb();\r\n            });\r\n        }else{\r\n            this.generateAllTranslations();\r\n            cb();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The main plugin function\r\n *\r\n * @param opts\r\n * @returns {Stream}\r\n */\r\nexport function parse(opts) {\r\n    return new Parser(opts).parse();\r\n}\r\n"]}